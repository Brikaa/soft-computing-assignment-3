- Limitations
  - Two and only two variables are allowed on LHS of rule
  - Rule RHS can only have one variable
  - No intermediate output

- Structs: line, range, rule, assignment

Range = {
  begin: float,
  end: float
}

Line = {
  slope: float,
  y_intercept: float,
  x_range: Range
}

Assignment = {
  not: bool,
  var: string
  set: string
}

Rule = {
  lhs: {
    assignment_a: Assignment,
    operator: 'AND' | 'OR',
    assignment_b: Assignment
  },
  rhs: Assignment
}

rules = Rule[]

variables = {
  "var_name": {
    "set_name": Line[],
    ...
  },
  ...
}

fuzzy_values = {
  "var_name": {
    "set_name": float from 0 to 1,
    ...
  } (map for input, multimap for output),
  ...
}

- choose_name_from_map(map, exclude_fn)
  - i = 1
  - variable_names = []
  - for name in map
    - if exclude_fn(name)
      - continue
    - variable_names.append(name)
    - print("{i}. {name}")
    - i++
  - number = input() - 1
  - return variable_names[number]

- add_rule(input_variables, output_variables, rules)
  - if input_variables.size() == 0 || output_variables.size() == 0
    - print insufficient input and/or output variables to create a rule
  - rule_variables = []
  - rule_nots = []
  - rule_sets = []
  - operator = ""
  - for i:1..=3
    - var_pool = i == 3 ? output_variables : input_variables
    - var_name = choose_name_from_map(var_pool, (_) => false)
    - rule_variables.append(var_name)
    - print("1. is\n2. is not")
    - not_choice = input in range 1, 2
    - rule_nots.push(not_choice == 2)
    - set_name = choose_name_from_map(var_pool[var_name], (_) => false)
    - rule_sets.push(set_name)
    - if i == 1:
      - print("1. and\n2. or")
      - operator_choice = input() in range 1, 2
      - operator = operator_choice == 1 ? AND : OR
    - if i == 2:
      - print("=>")
  - assignment_a = assignment{ rule_nots[0], rule_variables[0], rule_sets[0] }
  - assignment_b = assignment{ rule_nots[1], rule_variables[1], rule_sets[1] }
  - lhs = LHS{assignment_a, operator, assignment_b}
  - rhs_assignment = assignment{ rule_nots[2], rule_variables[2], rule_sets[2] }
  - rules.push(Rule{LHS, rhs_assignment})

- calculate_fuzzy_value_for_variable(variables, variable_name, set_name, crisp_value)
  - lines = variables[variable_name][set_name]
  - range = [lines[0].range.begin, lines[lines.size() - 1].range.end]
  - for line in lines
    - if crisp_value >= line.range_x.begin && crisp_value <= line.range_x.end
      - if line.slope == inf
        - return 1
      - return line.slope * crisp_value + line.y_intercept
  - return 0

- add_variable(variables)
  - var_name = input()
  - variables.set(var_name, {});
  - no_sets = input()
  - for 1..=no_sets
    - set_name = input()
    - set_type = input()
    - no_points = set_type == 'trapezoid' ? 4 : 3
    - xs = []
    - for j=1..=no_points
      - xs.append(input())
    - lines = []
    - ys = [0]
    - for i=2..no_points
      - ys.append(1)
    - ys.append(0)
    - for j=1..no_points
      - slope = (ys[j] - ys[j - 1])/(xs[j] - xs[j - 1])
      - lines.append(new Line{
          slope,
          y_intercept: ys[j] - slope * xs[j],
          range: [xs[j - 1], xs[j]]
        })
    - variables['var_name'].set('set_name', lines)

- calculate_crisp_output(input_variables, output_variables, rules)
  - if rules.size() == 0
    - Need at least one rule to calculate crisp output
  - input_crisp_values = {}
  - output_fuzzy_values = {} (multimap)
  - for rule in rules
    - var_a = rule.lhs.assignment_a.var
    - var_b = rule.lhs.assignment_b.var
    - a_crisp = input_crisp_values.has(var_a)
      ? input_crisp_values[var_a]
      : input('{var_a} crisp value')
    - b_crisp = input_crisp_values.has(var_b)
      ? input_crisp_values[var_b]
      : input('{var_b} crisp value')
    - a_fuzzy = calculate_fuzzy_value_for_variable(input_variables, var_a, rule.lhs.assignment_a.set, a_crisp)
    - b_fuzzy = calculate_fuzzy_value_for_variable(input_variables, var_b, rule.lhs.assignment_b.set, b_crisp)
    - if (rule.lhs.assignment_a.not) a_fuzzy = 1 - a_fuzzy
    - if (rule.lhs.assignment_b.not) b_fuzzy = 1 - b_fuzzy
    - fn = operator == "AND" ? min : max
    - c_fuzzy = fn(a_fuzzy, b_fuzzy)
    - if (rule.rhs.not) c_fuzzy = 1 - c_fuzzy
    - if (!output_fuzzy_values.has(rule.rhs.var))
      - output_fuzzy_values.set(rule.rhs.var, {})
    - output_fuzzy_values[rule.rhs.var].set(rule.rhs.set, c_fuzzy)
  # for each variable in output fuzzy values, calculate the output crisp value and check which set it lies in
  - for (var_name, set) in output_fuzzy_values (beware of multimap)
    - numerator = 0
    - denominator = 0
    - for (set_name, fuzzy_value) in set
      # numerator += centroid * fuzzy_value
      # denominator += value
      - centroid = 0
      - lines = output_variables[var_name][set_name]
      - for line in lines
        - centroid += line.x_range.begin
      - centroid += lines[lines.size() - 1].end
      - centroid /= lines.size() + 1
      - numerator += centroid * fuzzy_value
      - denominator += fuzzy_value
    - crisp_value = numerator / denominator
    # Check which set it lies in
    - set_name = "invalid set"
    - for (s, lines) in output_variables[var_name]
      - found = false
      - for line in lines
        - if crisp_value >= line.range_x.begin && crisp_value <= line.range_x.end
          - set_name = s
          - found = true
          - break
      - if (found) break
    - print("{var_name}: {crisp_value} (set_name)")
