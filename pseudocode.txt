- Limitations
  - Only two variables allowed on LHS of rule
  - No intermediate output

- Structs: line, range

variables = {
  "var_name": {
    "triangular_set": [
      {
        slope: 1/(second - first),
        y_intercept: -slope * first,
        range: [first, second]
      },
      {
        slope: -1/(third-second),
        y_intercept: -slope * third,
        range: [second, third]
      }
    ],
    "trapezoidal_set": [
      {
        slope: 1/(second - first),
        y_intercept: -slope * first,
        range: [first, second]
      },
      {
        slope: 0,
        y_intercept: 1,
        range: [second, third]
      },
      {
        slope: 1/(fourth - third),
        y_intercept: -slope * fourth,
        range: [third, fourth]
      }
    ]
  }
}

fuzzy_values = {
  "var_name": {
    "triangular_set": 0.8,
    "trapezoidal_set": 0.3
  }
}

- calculate_fuzzy_values_for_variable(variables, fuzzy_values)
  - variable_names = []
  - i = 1
  - for variable_name in variables
    - if variable_name in fuzzy_values
      - continue
    - variable_names.append(variable_name)
    - print("{i}. {variable_name}")
    - i++
  - number = input() - 1
  - variable_name = variable_names[number]
  - fuzzy_values.set(variable_name, {})
  - sets = variables[variable_name]
  - for set_name in sets:
    - lines = sets[set_name]
    - range = [lines[0].range.begin, lines[lines.size() - 1].range.end]
    - value = input("for {set_name}") in range
    - for line in lines
      - if value >= line.range.begin && value <= line.range.end
        - fuzzy_value = line.slope * value + line.y_intercept
        - fuzzy_values[variable_name].set(set_name, fuzzy_value)
        - break

- add_variable(variables)
  - var_name = input()
  - variables.set(var_name, {});
  - no_sets = input()
  - for 1..=no_sets
    - set_name = input()
    - set_type = input()
    - no_points = set_type == 'trapezoid' ? 4 : 3
    - xs = []
    - for j=1..=no_points
      - xs.append(input())
    - lines = []
    - ys = [0]
    - for i=2..no_points
      - ys.append(1)
    - ys.append(0)
    - for j=1..no_points
      - slope = (ys[j] - ys[j - 1])/(xs[j] - xs[j - 1])
      - lines.append(new Line{
          slope,
          y_intercept: ys[j] - slope * xs[j]
        })
    - variables['var_name'].set('set_name', lines)

- For each variable
  - For each fuzzy set
    - Determine the degree of membership (fuzzy values of input sets)
- Do rule inference using these degree of memberships (fuzzy values of output sets)
- Do defuzzification using inference results (crisp value of output)
